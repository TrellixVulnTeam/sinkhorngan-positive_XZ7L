import numpy as np
import torch

from modules.trainer import UpdaterBase


class RAWGAN(UpdaterBase):

    def __init__(self, params, network, pre_train=None):
        super().__init__(params, network, pre_train)

        # Set optimizer
        for name in self.models.keys():
            self.models.set_optim(net=name, optimizer=torch.optim.RMSprop, lr=self.params["optimizer"]["lr_" + name])

        # Add fixed sample for testing
        self.fixed_samples = {
            "z_input": self.FloatTensor(
                np.random.normal(0, 1, (self.params["train"]["generated_size"], self.params["network"]["z_dim"])))
        }

    def update_parameters_discriminator(self, z, x, y):
        # Check D with real data
        d_real = self.models["Dis"](x)

        # Check D with fake data generated by G
        gen_x = self.models["Gen"](z.detach())
        d_fake = self.models["Dis"](gen_x)

        real_loss = d_real - d_fake.mean(0, keepdim=True)
        fake_loss = d_fake - d_real.mean(0, keepdim=True)

        loss = torch.mean(fake_loss) - torch.mean(real_loss)
        loss.backward()

        return loss

    def update_parameters_generator(self, z, x, y):
        # Check D with real data
        d_real = self.models["Dis"](x).detach()

        # check G net
        gen_x = self.models["Gen"](z)
        d_fake = self.models["Dis"](gen_x)

        # calculate criterion
        loss = -torch.mean(d_fake - d_real.mean(0, keepdim=True))
        loss.backward()

        return loss
